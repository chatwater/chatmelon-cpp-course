#include <iostream>
using namespace std;
// 神奇的幻方: 当n为奇数时，可用以下方法按顺序用1~n*n填入n*n的方阵，使得每行、每列、两条对角线上的数字之和相等
// 二维数组
int n, g[40][40], x, y;
int main() {
    cin >> n; // 输入幻方的大小
    if(n % 2 == 0) { // 如果n为偶数，不对的，这个方法只适用于奇数
        cout << "n必须是奇数！" << endl; // 输出错误信息
        return 0; // 结束程序
    }
    g[1][n / 2 + 1] = 1; // 将1放在第一行的中间
    x = 1; // 行置为1
    y = n / 2 + 1; // 列置为中间列
    for(int i = 2; i <= n * n; i++) {
        if(x ==1 && y != n){
            g[n][y + 1] = i; // 如果在第一行且不在最后一列
            x = n; // 移动到最后一行
            y++; // 列加1
        }else if(x != 1 && y == n){
            g[x - 1][1] = i; // 如果不在第一行且在最后一列
            x--; // 行减1
            y = 1; // 列置为1
        }else if (x == 1 && y == n){
            g[2][n] = i; // 如果在第一行且在最后一列
            x = 2; // 行置为2
        }else if (x != 1 && y != n){
            if(g[x - 1][y + 1] == 0){ // 如果上方和右方都没有数字
                g[x - 1][y + 1] = i; // 将数字放在上方和右方
                x--; // 行减1
                y++; // 列加1
            }else{
                g[x + 1][y] = i; // 否则放在下方
                x++; // 行加1
            }
            continue; // 继续循环
        }
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            cout << g[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
/*
效果如下：

输入：
5

输出：
17 24 1 8 15 
23 5 7 14 16 
4 6 13 20 22 
10 12 19 21 3 
11 18 25 2 9 

*/